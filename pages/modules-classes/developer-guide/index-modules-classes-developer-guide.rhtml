<c:template
    xmlns:c="core"
    xmlns:html="html"
    xmlns:optimizer="optimizer"
    xmlns:w="widgets"
    xmlns:docs="docs"
    params="includes,samples"
    docs:functions="url">

    <optimizer:page name="${data.pageName}" base-path="${data.pageOutputDir}">
        <dependencies>
            <module name="docs-global"/>
            <module name="components/nav/TopNavDefault"/>
            <module name="components/footers/FooterDefault"/>
            <module name="components/docs/Docs"/>
            <module name="components/editors/CodeEditor"/>
            <css path="index.css"/>
        </dependencies>
    </optimizer:page>
    
    
    <html html:doctype="html">
        <docs:head title="RaptorJS: Modules &amp; Classes">
        </docs:head>
        <body data-spy="scroll">
            <docs:top-nav activeItem="modules-classes"/>
            <div class="container">
                <docs:docs heading="Getting Started with Modules, Classes, Mixins and Enums" disqus-id="modules-developer-guide">
                    <docs:section heading="Introduction">
                        <p>
                            Out of the box, JavaScript lacks basic support for namespaces, 
                            and defining and using "classes" is not always elegant. 
                            Because JavaScript is a very dynamic language many libraries
                            and frameworks have been developed to address some of these
                            shortcomingsâ€”each with their own benefits and disadvantages.
                        </p>
                        <p>
                            RaptorJS provides a simple library for
                            defining namespaced modules, classes, mixins and enums.
                            This library uses a clean and easy-to-understand
                            syntax based on the <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">Asynchronous Module Definition (AMD)</a> syntax. 
                            RaptorJS provides an AMD implementation that extends AMD in backwards compatible
                            ways to provide new features that make
                            building modular JavaScript applications even easier.
                            The syntax is is very close to pure JavaScript, but
                            fills gaps in the existing JavaScript language.
                            Now you can start creating modular code
                            that is easy to maintain without waiting for
                            a new version of JavaScript or switching to an
                            alternate language.
                        </p>
                        <p>
                            The RaptorJS AMD implementation can be loaded on the server (under Node.js and Rhino)
                            or in the browser
                            <nobr>(<docs:popover>
                                 <docs:popover-content>
                                     Not including a 
                                     partial EcmaScript 5 shim
                                     required for older web browsers.
                                 </docs:popover-content>
                                  ~1.8k gzipped
                             </docs:popover>)</nobr>. 
                             To generate a build for the browser you can use the following command
                             after installing Node.js and the "raptor" module (see 
                             <a href="${url('/get-started')}">Get Started</a>
                             guide):
                        </p>
                        <pre class="sh" xml:space="preserve" c:trim-body-indent="true">
                        raptor-optimizer raptor --name raptor --out build --minify
                        </pre>
                        <p>
                            The above command will generate a file named "raptor.js" in 
                            a nested "build" directory. The core "raptor" module includes the core
                            module system for RaptorJS which supports
                            AMD, class inheritance, mixins and enums. The generated file also includes optional polyfills
                            for <a href="https://github.com/raptorjs/raptorjs/tree/master/lib/raptor/ecma/es5">EcmaScript 5</a> and
                            <a href="https://github.com/raptorjs/raptorjs/tree/master/lib/raptor/ecma/es6">EcmaScript 6</a> which are only needed on older browsers. These
                            polyfills can be excluded in the generated file by using the following command instead:
                        </p>
                        <pre class="sh" xml:space="preserve" c:trim-body-indent="true">
                        raptor-optimizer raptor --name raptor --out build --minify --extensions no-es5,no-es6
                        </pre>
                        <p>
                            The "--extensions" switch is used to enable one or more extensions that is used
                            to control how resources are packaged and optimized. See the following package.json file for an example:
                            <a href="https://github.com/raptorjs/raptorjs/blob/master/lib/raptor/ecma/es5/package.json">raptor/ecma/es5/package.json</a>
                        </p>
                        <p>
                            RaptorJS includes a <a href="http://raptorjs.org/packaging/">very flexible packaging system</a> that is used by the 
                            <a href="http://raptorjs.org/optimizer/">RaptorJS Optimizer</a>
                            to give developers full
                            control over what code gets included on a particular web page.
                        </p>
                    </docs:section>
                    <docs:section heading="Basic Usage">
                        <p>
                            The RaptorJS AMD implementation follows the basic pattern for defining 
                            objects which is to associate a 
                            <i>factory function</i> with a
                            <i>string</i> ID. The job of the factory function
                            is to return the initialized object when it is first
                            required.
                        </p>
                        <docs:section heading="Defining">
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define(
                                'some/namespace/my-module', 
                                function(require, exports, module) {
                                    return { //Return the module definition
                                        sayHello: function() {
                                            console.log("Hello World!");
                                        }
                                    }
                                });
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                        <docs:section heading="Requiring">
                            <p>
                                To "require" an object using RaptorJS, the <code>require(id)</code>
                                function should be used. The <code>require(id)</code> function will
                                initialize the required object if it had not previously required. An object
                                is initialized by invoking the factory function to get back the final object.
                                The initialized object is then cached so that it can simply be returned for subsequent requires
                                of the same object ID.
                            </p>
                            <p>
                                On the server-side, if <code>require(id)</code> is invoked
                                and the object has not been registered then RaptorJS goes through a resolving
                                phase to find and load the requested object from disk.
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            var myModule = require('some/namespace/my-module');
                            myModule.sayHello();
                            ]]>
                            </docs:code-editor>
                            <p>
                                Asynchronous "requiring" of function is also supported. Please
                                see the <a href="#RequireAsync">require(ids, callback)</a>
                                section below.
                            </p>
                        </docs:section>
                    </docs:section>
                    <docs:section heading="Require">
                        <docs:section heading="require(id)" anchor-name="RequireSync">
                            <p>
                                The <code>require(id)</code> function should be used to synchronously
                                get a reference to another module/class/mixin/enum as shown in
                                the following sample code:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            var myModule = require('some/namespace/my-module');
                            myModule.sayHello();
                            ]]>
                            </docs:code-editor>
                            <docs:message type="info">
                                <p>
                                    NOTE: When using synchronous <code>require(id)</code> function, the code for
                                    the requested module must be available. For asynchronous loading,
                                    please see the next section.
                                </p>
                            </docs:message>
                        </docs:section>
                        <docs:section heading="require(ids, callback)" anchor-name="RequireAsync">
                            <p>
                                The <code>require(ids, callback)</code> function should be used to asynchronously
                                load one or more modules and get a reference to the loaded modules. The following code
                                illustrates how the asynchronous require function can be used:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            require(['a', 'b', 'c'], function(a, b, c) {
                                //Modules a, b and c are ready to be used
                            }); 
                            ]]>
                            </docs:code-editor>
                            <docs:message type="info">
                                <p>
                                    Asynchronous module loading
                                    (loading a module asynchronously from a server) is provided
                                    by the <a href="${url('/module-loader')}">RaptorJS Asynchronous Module Loader</a>.
                                    The <code><a href="">raptor/loader</a></code> module must be
                                    included on the page for asynchronous module loading to work. In
                                    addition, any modules that are to be loaded asynchronously
                                    must be added as an "async" dependency. Please see the 
                                    documentation for the <a href="${url('/module-loader')}">RaptorJS Asynchronous Module Loader</a>
                                    for more details.
                                </p>
                            </docs:message>
                        </docs:section>
                        <docs:section heading="require.find(id)" anchor-name="RequireFind">
                            <p>
                                The <code>require.find(id)</code> method can be used to get a reference to a module. Unlike the <code>require</code> function, <code>require.find(id)</code> will return null if a module with the specified ID is not found.
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            var myModule = require.find('my-module');
                            if (myModule) {
                                // Module found
                            }
                            else {
                                // Module not found
                            }
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                        <docs:section heading="require.exists(id)" anchor-name="RequireExists">
                            <p>
                                The <code>require.exists(id)</code> method can be used to check if a module exists with the specified module ID. The method will return <code>true</code> of the module exists, <code>false</code> otherwise.
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            if (require.exists('my-module') {
                                // Module exists
                            }
                            else {
                                // Module does not exist
                            }
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                    </docs:section>
                    <docs:section heading="Modules">
                        <docs:section heading="Defining a Module">
                            <p>
                                A JavaScript object/module can be associated with a name as shown in the following
                                example:    
                            </p>
                            
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define(
                                'some/namespace/my-module', 
                                function(require, exports, module) {
                                    return { //Return the module definition
                                        sayHello: function() {
                                            console.log("Hello World!");
                                        }
                                    }
                                });
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                    </docs:section>
                    <docs:section heading="Classes">
                        <docs:section heading="Defining a Class" anchor-name="DefineClass">
                            <p>
                                A class can be defined by creating a factory function that returns a constructor function 
                                (with a <code>prototype</code> property) as shown in the following example:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define(
                                'some/namespace/MyClass', 
                                function(require, module, exports) {
                                    var MyClass = function(message) { //Constructor function
                                        this.message = message;
                                    }

                                    MyClass.prototype = {
                                        sayHello: function() {
                                            console.log(this.message);
                                        }
                                    };

                                    return MyClass;
                                });
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                        <docs:section heading="Creating an Instance of a Class">
                            <p>
                                An instance of a class can be created as shown in the following example:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            var MyClass = require("some/namespace/MyClass");
                            var myInstance = new MyClass();
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                        <docs:section heading="Inheritance">
                            <p>
                                Prototype-based class inheritance is also supported by RaptorJS when using the
                                <code>define.Class</code> method. The signature for the <code>define.Class</code> method is the following:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define.Class(id, ?superclassId, ?dependencies, factory) 
                            ]]>
                            </docs:code-editor>
                            <p>
                                Example:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define.Class(
                                'some/namespace/Dog', 
                                'some/namespace/Animal', //Name of the superclass
                                function(require, exports, module) {
                                    var Dog = function(breed) {
                                        // Invoke the constructor of the superclass:
                                        Dog.superclass.constructor.call(this, "dog"); 
                                        this.breed = breed;
                                    }

                                    Dog.prototype = {
                                        eat: function(food) {
                                            // Invoke the "eat" method in the superclass:
                                            Dog.superclass.eat.apply(this, food); 
                                            this.bark();
                                        },

                                        bark: function() {
                                            console.log("woof!");
                                        }
                                    };

                                    return Dog;
                                });
                            ]]>
                            </docs:code-editor>
                            <docs:message type="info">
                                <p>
                                    The superclass argument can also be passed as part of a modifiers
                                    object as shown in the following example:
                                </p>
                                <docs:code-editor 
                                    autoResize="true"
                                    indentUnit="4"
                                    readOnly="true"
                                    mode="javascript">
                                <![CDATA[
                                define.Class(
                                    'some/namespace/Dog', 
                                    {
                                        superclass: 'some/namespace/Animal' //Name of the superclass
                                    }, 
                                    function(require, exports, module) {
                                        ...
                                    });
                                ]]>
                                </docs:code-editor>
                                <p>
                                    This allows an anonymous class with a superclass to be define:
                                </p>
                                <docs:code-editor 
                                    autoResize="true"
                                    indentUnit="4"
                                    readOnly="true"
                                    mode="javascript">
                                <![CDATA[
                                define.Class( 
                                    {
                                        superclass: 'some/namespace/Animal' //Name of the superclass
                                    }, 
                                    function(require, exports, module) {
                                        ...
                                    });
                                ]]>
                                </docs:code-editor>
                            </docs:message>
                            <docs:message type="info">
                                <p>
                                    NOTE: When defining a class that extends another class, the returned constructor
                                    function is populated with a "superclass" property that is a
                                    reference to the prototype of the superclass. In addition,
                                    the prototype of a class is always populated with a "constructor" property,
                                    which is a reference to the constructor function for the class associated
                                    with the prototype object.
                                </p>
                            </docs:message>
                        </docs:section>
                    </docs:section>
                    <docs:section heading="Mixins">
                        <docs:section heading="Defining a Mixin">
                            <p>
                                RaptorJS allows mixins to be applied to an object in two different ways:
                            </p>
                            <ol>
                                <li>As part of an object definition</li>
                                <li>External from the object being defined</li>
                            </ol>
                        </docs:section>
                        <docs:section heading="raptor.extend(target, mixins)">
                            <p>
                                Mixins can be applied declaratively as part of
                                an object definition as shown in the following example
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define.Class(
                                'some/namespace/CircleButton',
                                ['raptor'],
                                function(raptor, require) {
                                    var CircleButton = function() {
                                    };
                                    
                                    CircleButton.prototype = {
                                        //...
                                    }
                                    
                                    //Apply mixins to the CircleButton's prototype:
                                    raptor.extend(
                                        CircleButton.prototype, 
                                        require('some/namespace/CircleMixin'));
                                    
                                    //NOTE: raptor.extend simply copies properties from one object to another
                                    
                                    return CircleButton;
                                });
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                        <docs:section heading="define.extend(targetId, factory)" anchor-name="DefineExtend">
                            <p>
                                The <code>define.extend</code> method allows mixins to be lazily applied to another 
                                module when the module is first required. The <code>define.extend</code> method is used 
                                heavily to support cross-environment modules by creating environment specific 
                                mixins for modules. Example:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            /**
                             * Extends the "raptor/files" module with Rhino/Java specific mixins so that the
                             * same module can work in multiple server-side JavaScript environments.
                             * @extension Rhino
                             */
                            define.extend(
                                'raptor/files',
                                function(require) {
                                    var JavaFile = Packages.java.io.File;
                            
                                    return {
                                        exists: function(path) {
                                            return new JavaFile(path).exists();
                                        }
                                    }
                                }
                            );
                            ]]>
                        </docs:code-editor>
                        </docs:section>
                    </docs:section>
                    <docs:section heading="Enums" anchor-name="DefineEnum">
                        <docs:section heading="Defining an Enum">
                            <p>
                                An enum type can be defined as shown in the following example:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define.Enum(
                                'some/namespace/Day',
                                [
                                    "SUN",
                                    "MON",
                                    "TUE",
                                    "WED",
                                    "THU",
                                    "FRI",
                                    "SAT"
                                ]
                            );
                            ]]>
                            </docs:code-editor>
                            <p>
                                Enum values as complex objects can be defined as shown in the following example:
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define.Enum(
                                'some/namespace/Day',
                                {
                                    SUN: [false, "Sunday"],
                                    MON: [true, "Monday"],
                                    TUE: [true, "Tuesday"],
                                    WED: [true, "Wednesday"],
                                    THU: [true, "Thursday"],
                                    FRI: [true, "Friday"],
                                    SAT: [false, "Saturday"]
                                },
                                function(require) {
                                    return {
                                        init: function(isWeekday, longName) {
                                            this._isWeekday = isWeekday;
                                            this._longName = longName;
                                        },
                                         
                                        getLongName: function() {
                                            return this._longName;
                                        },
                                         
                                        isWeekday: function() {
                                            return this._isWeekday;
                                        }
                                    }
                                }
                            );
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                        <docs:section heading="Enum Methods">
                            <p>Every enum class supports the following methods.</p>
                            <ul>
                                <li>valueOf(name) - Returns the constant field with the same name (case sensitive)</li>
                            </ul>
                            <p>Every enum field supports the following methods.</p>
                            <ul>
                                <li>
                                    name() - Returns the name of the enum
                                </li>
                                <li>
                                    ordinal() - Returns the positional value of the enum (NOTE: This
                                    should only be used for an array of enum strings. Order is undefined
                                    for maps but it will work correctly in most browsers.)
                                </li>
                                <li>
                                    toString() - Returns the name of the enum unless it has been overridden
                                </li>
                                <li>
                                    compareTo(other) - Compares one enum field to another based on the ordinal value
                                </li>
                            </ul>
                        </docs:section>
                        
                        <docs:section heading="Enum Usage">
                            <p>
                                Once you define an enum, the enum constants can be accessed as
                                static properties of the class as shown in the following example.
                            </p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            var Day = require('some/namespace/Day');
                            if (day === Day.FRI) {
                                alert("It is " + day.getLongName() + "!");
                            }
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                    </docs:section>

                    <docs:section heading="Anonymous Objects">
                        <p>
                            Anonymous (unnamed objects) can be defined
                            by omitting the name argument. For example:
                        </p>
                        <docs:code-editor 
                            autoResize="true"
                            indentUnit="4"
                            readOnly="true"
                            mode="javascript">
                        <![CDATA[
                        var myModule = define(
                            function() {
                                return {
                                    sayHello: function() {
                                        console.log("Hello World!");
                                    }
                                }
                            });
                        myModule.sayHello();
                        ]]>
                        </docs:code-editor>
                    </docs:section>
                    
                    <docs:section heading="Logging" anchor-name="ModuleLogger">
                        <p>
                            The module argument that is passed to a factory function supports a new logger method that can be used to obtain a reference to a logger for the module/class being defined. For Example:
                        </p>
                        <p>
                            <docs:code-editor 
                                autoResize="true"
                                indentUnit="4"
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define(
                                'some/namespace/my-module', 
                                function(require, exports, module) {
                                    var logger = module.logger();
                                    logger.debug("This is a debug message"); 
                                    /* 
                                    Console Output: 
                                    DEBUG some/namespace/my-module This is a debug message
                                    */
                                });
                            ]]>
                            </docs:code-editor>
                        </p>
                        <p>
                            For more details on logging, see <a href="${url('/logging')}">RaptorJS Logging</a>.
                        </p>
                    </docs:section>
                    <docs:section heading="Differences from the AMD Spec">
                        <p>
                            The RaptorJS AMD implementation introduces some <b>backwards compatible</b> 
                            improvements to the AMD specification that are described below:
                        </p>
                        <docs:section heading="Module IDs">
                            <p>
                                Using dots as the separators instead of forward slashes is supported and module IDs will normalized by converting all dots to forward slashes. However, it is recommended to use forward slashes to be AMD-compliant.
                            </p>
                        </docs:section>
                        <docs:section heading="Factory Function Arguments">
                            <p>
                                For RaptorJS, the last three arguments will always be [require, exports, module]. If an array of dependency IDs is provided then those dependencies will be passed in before the three built-in arguments. For example:
                            </p>
                            <docs:code-editor 
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define(
                                'some/namespace/my-module', 
                                ['a', 'b', 'c'],
                                function(a, b, c, require, exports, module) {
                                    //...
                                });
                            ]]>
                            </docs:code-editor>
                            <p>
                                Developer code can still explicitly reference "require", "exports" and "module" as shown in the following example code:
                            </p>
                            <docs:code-editor 
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            define(
                                'some/namespace/my-module', 
                                ['require', 'exports', 'module', 'a', 'b', 'c'],
                                function(require, exports, module, a, b, c) {
                                    //...
                                });
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                        <docs:section heading="Sync and Async require">
                            <p>
                                Like most AMD implementations, RaptorJS supports both a synchronous "require" function and an asynchronous "require" function:
                            </p>
                            <ul>
                                <li>
                                    <b>Synchronous:</b> <code>require(id)</code>
                                </li>
                                <li>
                                    <b>Asynchronous:</b> <code>require(ids, callback)</code>
                                </li>
                            </ul>
                            <p>
                                Asynchronous loading requires the that separate raptor/loader/require module be included as part of the initial page load.
                            </p>
                        </docs:section>
                        <docs:section heading="Asynchronous Package Loading">
                            <p>
                                RaptorJS will not provide any support for loader plugins. Instead, RaptorJS will allow any "package" of code to be downloaded asynchronously. For a given package to be downloaded asynchronously, the client must be provided with the list of required JavaScript or CSS URLs for each package/module upfront (which the <a href="${url('/optimizer')}">RaptorJS Optimizer</a> tool will do for you automatically). The RaptorJS Optimizer will generate the required metadata (including JavaScript and CSS urls) that is required to download packages asynchronously. With this approach, developers no longer have to worry about configuring the client with base paths and the server will always generate cacheable URLs that can optionally be delivered through a CDN. During development, URLs are generated such that each file resource has a unique URL that points to the original file on disk. In comparison, during a production build, file resources are concatenated together as part of a single resource/URL and resources are minified based on the optimizer's configuration.
                            </p>
                            <p>
                                Modules/packages can be downloaded using asynchronous version of the require function (i.e. <code>require(ids, callback)</code> method. For example:
                            </p>
                            <docs:code-editor 
                                readOnly="true"
                                mode="javascript">
                            <![CDATA[
                            require(['a', 'b', 'c'], function(a, b, c) {
                                //Modules a, b and c are ready to be used
                            });
                            ]]>
                            </docs:code-editor>
                        </docs:section>
                        <docs:section heading="Global require function">
                            <p>
                                When loaded on the server or included in the browser, the "raptor" 
                                module introduces a global <code>require</code> function. This allows both the synchronous "require" function to be used outside the context of a define. If the "require" method is used outside the context of a define then absolute module names must be used (since there is nothing for the required module name to be relative to). This frees developers from having to create a "define" block just to make use of another module.
                            </p>
                        </docs:section>
                        <docs:section heading="Additional define methods">
                            <ul>
                                <li><a href="#DefineClass">define.Class(...)</a></li>
                                <li><a href="#DefineEnum">define.Enum(...)</a></li>
                                <li><a href="#DefineExtend">define.extend(...)</a></li>
                            </ul>
                        </docs:section>
                        <docs:section heading="Additional module methods">
                            <ul>
                                <li><a href="#ModuleLogger">module.logger()</a></li>
                            </ul>
                        </docs:section>
                        <docs:section heading="Additional require methods">
                            <ul>
                                <li><a href="#RequireFind">require.find(id)</a></li>
                                <li><a href="#RequireExists">require.exists(id)</a></li>
                            </ul>
                        </docs:section>
                    </docs:section>
                    <docs:section heading="Node Integration">
                        <p>
                            Node does not natively provide the "define" function that is required by AMD. RaptorJS solves this problem by modifying the Node runtime to automatically add a "define" function to every module. This is done by modifying the Node wrapper code to introduce an additional "define" parameter that gets initialized with a "define" function provided by RaptorJS. The "define" function understands the context where it is being defined which allows it to create a "require" function that wraps the Node provided require function so that it can be used to load both AMD modules and CommonJS modules on the server.
                        </p>
                        <p>
                            In addition, RaptorJS modifies the Node runtime to allow the native "require" function to be used to load both CommonJS modules and top-level (i.e. not relative) AMD modules. This is done by hooking into Node's path resolver.
                        </p>
                        <p>
                            The related code can be found in the following file: 
                            <a href="https://github.com/raptorjs/raptorjs/blob/master/lib/raptor/raptor_node.js">
                                /lib/raptor/raptor_node.js
                            </a>
                        </p>
                        <p>
                            The end result is a seamless integration of the AMD pattern into a Node server environment. The AMD functionality is enabled the first time the "raptor" module is required, but the "define" function will then only be available in modules that are subsequently loaded by Node. To manually create a "define" function the following code can be used:
                        </p>
                        <docs:code-editor 
                            readOnly="true"
                            mode="javascript">
                        <![CDATA[
                        var define = require('raptor').createDefine(module /* Node module object */);
                        ]]>
                        </docs:code-editor>
                    </docs:section>
                </docs:docs>
            </div>
            
            <optimizer:slot name="body"/>
            
            <w:init-widgets/>

        </body>
    </html>
</c:template>

